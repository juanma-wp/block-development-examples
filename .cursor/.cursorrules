You are an expert in Javascript, TypeScript and Node.js

Analysis Process

-   Before responding to any request, follow these steps:
    -   Request Analysis
        -   Determine task type (code creation, debugging, architecture, etc.)
        -   Identify languages and frameworks involved
        -   Note explicit and implicit requirements
        -   Define core problem and desired outcome
        -   Consider project context and constraints
    -   Solution Planning
        -   Break down the solution into logical steps
        -   Consider modularity and reusability
        -   Identify necessary files and dependencies
        -   Evaluate alternative approaches
        -   Plan for testing and validation
    -   Implementation Strategy
        -   Choose appropriate design patterns
        -   Consider performance implications
        -   Plan for error handling and edge cases
        -   Ensure accessibility compliance
        -   Verify best practices alignment

Response Constraints

-   Do not remove any existing code unless necessary
-   Do not remove my comments or commented-out code unless necessary
-   Do not change the formatting of my imports
-   Do not change the formatting of my code unless important for new functionality

Code Style and Structure

-   Write concise, technical TypeScript code with accurate examples
-   Use functional and declarative programming patterns; avoid classes
-   Prefer iteration and modularization over code duplication
-   Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError)
-   Structure files: exported component, subcomponents, helpers, static content, types
-   Follow DRY (Don't Repeat Yourself) principle
-   Implement early returns for better readability

Naming Conventions

-   Use lowercase with dashes for directories (e.g., components/auth-wizard)
-   Favor named exports for components
-   Use descriptive names with auxiliary verbs (isLoading, hasError)
-   Prefix event handlers with "handle" (handleClick, handleSubmit)
-   Use lowercase with dashes for directories (components/auth-wizard)
-   Favor named exports for components

TypeScript Usage

-   Use TypeScript for all code; prefer interfaces over types
-   Avoid enums; use maps instead
-   Use functional components with TypeScript interfaces
-   Use TypeScript for all code
-   Prefer interfaces over types
-   Implement proper type safety and inference
-   Use satisfies operator for type validation
-   Use webpack as a bundler

Typescript config

```
{
  "compilerOptions": {
    "target": "es2018",
    "module": "commonjs",
    "moduleResolution": "node",
    "sourceMap": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "exclude": ["node_modules", "webpack.config.js", "webpack.config.prod.js"]
}
```

Webpack config

_`webpack.config`_

```
const path = require("path");
const nodeExternals = require("webpack-node-externals");

module.exports = {
  mode: "development",
  target: "node",
  entry: "./src/app.ts",
  output: {
    filename: "app.js",
    path: path.resolve(__dirname, "dist"),
  },
  devtool: "inline-source-map",
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: "ts-loader",
        exclude: /node_modules/,
      },
    ],
  },
  resolve: {
    extensions: [".ts", ".js"],
  },
  externals: [nodeExternals()],
};

```

_`webpack.config.prod`_

```
const path = require("path");
const nodeExternals = require("webpack-node-externals");
const CleanPlugin = require("clean-webpack-plugin");

module.exports = {
  mode: "production",
  target: "node",
  entry: "./src/app.ts",
  output: {
    filename: "app.js",
    path: path.resolve(__dirname, "dist"),
  },
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: "ts-loader",
        exclude: /node_modules/,
      },
    ],
  },
  resolve: {
    extensions: [".ts", ".js"],
  },
  externals: [nodeExternals()],
  plugins: [new CleanPlugin.CleanWebpackPlugin()],
};

```

Package.json config

```
{
  "main": "dist/app.js",
  "scripts": {
    "build": "webpack --config webpack.config.prod.js",
    "start": "webpack --watch --config webpack.config.js & nodemon",
    "clean": "rm -rf dist"
  },
  "dependencies": {
    "express": "^4.17.1"
  },
  "devDependencies": {
    "@types/express": "^4.17.13",
    "@types/node": "^16.11.7",
    "clean-webpack-plugin": "^4.0.0",
    "nodemon": "^2.0.22",
    "ts-loader": "^9.5.1",
    "typescript": "^4.9.5",
    "webpack": "^5.97.1",
    "webpack-cli": "^4.10.0",
    "webpack-node-externals": "^3.0.0"
  },
  "nodemonConfig": {
    "watch": [
      "dist"
    ],
    "exec": "node dist/app.js",
    "ext": "js"
  }
}

```

Syntax and Formatting

-   Use the "function" keyword for pure functions
-   Use curly braces for all conditionals. Favor simplicity over cleverness

Code Quality

-   Implement comprehensive error handling
-   Write maintainable, self-documenting code
-   Follow security best practices
-   Ensure proper type coverage
-   Use ESLint and Prettier

Testing Strategy

-   Plan for unit and integration tests
-   Implement proper test coverage
-   Consider edge cases and error scenarios
-   Validate accessibility compliance

Performance Optimization

-   Look for ways to make things faster:
    -   Use immutable data structures
    -   Use efficient data fetching strategies
    -   Optimize network requests
    -   Use efficient data structures
    -   Use efficient algorithms
    -   Use efficient rendering strategies
    -   Use efficient state management
